Syntax trees:


======= voting.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.22;"
ContractDefinition "Ballot"
   Source: "contract Ballot {\n    // This declares a new complex type which will\n    // be used for variables later.\n    // It will represent a single voter.\n    struct Voter {\n        uint weight; // weight is accumulated by delegation\n        bool voted;  // if true, that person already voted\n        address delegate; // person delegated to\n        uint vote;   // index of the voted proposal\n    }\n\n    // This is a type for a single proposal.\n    struct Proposal {\n        bytes32 name;   // short name (up to 32 bytes)\n        uint voteCount; // number of accumulated votes\n    }\n\n    address public chairperson;\n\n    // This declares a state variable that\n    // stores a `Voter` struct for each possible address.\n    mapping(address => Voter) public voters;\n\n    // A dynamically-sized array of `Proposal` structs.\n    Proposal[] public proposals;\n\n    /// Create a new ballot to choose one of `proposalNames`.\n    constructor(bytes32[] proposalNames) public {\n        chairperson = msg.sender;\n        voters[chairperson].weight = 1;\n\n        // For each of the provided proposal names,\n        // create a new proposal object and add it\n        // to the end of the array.\n        for (uint i = 0; i < proposalNames.length; i++) {\n            // `Proposal({...})` creates a temporary\n            // Proposal object and `proposals.push(...)`\n            // appends it to the end of `proposals`.\n            proposals.push(Proposal({\n                name: proposalNames[i],\n                voteCount: 0\n            }));\n        }\n    }\n\n    // Give `voter` the right to vote on this ballot.\n    // May only be called by `chairperson`.\n    function giveRightToVote(address voter) public {\n        // If the first argument of `require` evaluates\n        // to `false`, execution terminates and all\n        // changes to the state and to Ether balances\n        // are reverted.\n        // This used to consume all gas in old EVM versions, but\n        // not anymore.\n        // It is often a good idea to use `require` to check if\n        // functions are called correctly.\n        // As a second argument, you can also provide an\n        // explanation about what went wrong.\n        require(\n            msg.sender == chairperson,\n            \"Only chairperson can give right to vote.\"\n        );\n        require(\n            !voters[voter].voted,\n            \"The voter already voted.\"\n        );\n        require(voters[voter].weight == 0);\n        voters[voter].weight = 1;\n    }\n\n    /// Delegate your vote to the voter `to`.\n    function delegate(address to) public {\n        // assigns reference\n        Voter storage sender = voters[msg.sender];\n        require(!sender.voted, \"You already voted.\");\n\n        require(to != msg.sender, \"Self-delegation is disallowed.\");\n\n        // Forward the delegation as long as\n        // `to` also delegated.\n        // In general, such loops are very dangerous,\n        // because if they run too long, they might\n        // need more gas than is available in a block.\n        // In this case, the delegation will not be executed,\n        // but in other situations, such loops might\n        // cause a contract to get \"stuck\" completely.\n        while (voters[to].delegate != address(0)) {\n            to = voters[to].delegate;\n\n            // We found a loop in the delegation, not allowed.\n            require(to != msg.sender, \"Found loop in delegation.\");\n        }\n\n        // Since `sender` is a reference, this\n        // modifies `voters[msg.sender].voted`\n        sender.voted = true;\n        sender.delegate = to;\n        Voter storage delegate_ = voters[to];\n        if (delegate_.voted) {\n            // If the delegate already voted,\n            // directly add to the number of votes\n            proposals[delegate_.vote].voteCount += sender.weight;\n        } else {\n            // If the delegate did not vote yet,\n            // add to her weight.\n            delegate_.weight += sender.weight;\n        }\n    }\n\n    /// Give your vote (including votes delegated to you)\n    /// to proposal `proposals[proposal].name`.\n    function vote(uint proposal) public {\n        Voter storage sender = voters[msg.sender];\n        require(!sender.voted, \"Already voted.\");\n        sender.voted = true;\n        sender.vote = proposal;\n\n        // If `proposal` is out of the range of the array,\n        // this will throw automatically and revert all\n        // changes.\n        proposals[proposal].voteCount += sender.weight;\n    }\n\n    /// @dev Computes the winning proposal taking all\n    /// previous votes into account.\n    function winningProposal() public view\n            returns (uint winningProposal_)\n    {\n        uint winningVoteCount = 0;\n        for (uint p = 0; p < proposals.length; p++) {\n            if (proposals[p].voteCount > winningVoteCount) {\n                winningVoteCount = proposals[p].voteCount;\n                winningProposal_ = p;\n            }\n        }\n    }\n\n    // Calls winningProposal() function to get the index\n    // of the winner contained in the proposals array and then\n    // returns the name of the winner\n    function winnerName() public view\n            returns (bytes32 winnerName_)\n    {\n        winnerName_ = proposals[winningProposal()].name;\n    }\n}"
  StructDefinition "Voter"
     Gas costs: 0
     Source: "struct Voter {\n        uint weight; // weight is accumulated by delegation\n        bool voted;  // if true, that person already voted\n        address delegate; // person delegated to\n        uint vote;   // index of the voted proposal\n    }"
    VariableDeclaration "weight"
       Type: uint256
       Source: "uint weight"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "voted"
       Type: bool
       Source: "bool voted"
      ElementaryTypeName bool
         Source: "bool"
    VariableDeclaration "delegate"
       Type: address
       Source: "address delegate"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "vote"
       Type: uint256
       Source: "uint vote"
      ElementaryTypeName uint
         Source: "uint"
  StructDefinition "Proposal"
     Gas costs: 0
     Source: "struct Proposal {\n        bytes32 name;   // short name (up to 32 bytes)\n        uint voteCount; // number of accumulated votes\n    }"
    VariableDeclaration "name"
       Type: bytes32
       Source: "bytes32 name"
      ElementaryTypeName bytes32
         Source: "bytes32"
    VariableDeclaration "voteCount"
       Type: uint256
       Source: "uint voteCount"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "chairperson"
     Type: address
     Gas costs: [???]
     Source: "address public chairperson"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "voters"
     Type: mapping(address => struct Ballot.Voter storage ref)
     Gas costs: [???]
     Source: "mapping(address => Voter) public voters"
    Mapping
       Source: "mapping(address => Voter)"
      ElementaryTypeName address
         Source: "address"
      UserDefinedTypeName "Voter"
         Source: "Voter"
  VariableDeclaration "proposals"
     Type: struct Ballot.Proposal storage ref[] storage ref
     Gas costs: [???]
     Source: "Proposal[] public proposals"
    ArrayTypeName
       Source: "Proposal[]"
      UserDefinedTypeName "Proposal"
         Source: "Proposal"
  FunctionDefinition "" - public
     Source: "constructor(bytes32[] proposalNames) public {\n        chairperson = msg.sender;\n        voters[chairperson].weight = 1;\n\n        // For each of the provided proposal names,\n        // create a new proposal object and add it\n        // to the end of the array.\n        for (uint i = 0; i < proposalNames.length; i++) {\n            // `Proposal({...})` creates a temporary\n            // Proposal object and `proposals.push(...)`\n            // appends it to the end of `proposals`.\n            proposals.push(Proposal({\n                name: proposalNames[i],\n                voteCount: 0\n            }));\n        }\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32[] proposalNames)"
      VariableDeclaration "proposalNames"
         Type: bytes32[] memory
         Source: "bytes32[] proposalNames"
        ArrayTypeName
           Source: "bytes32[]"
          ElementaryTypeName bytes32
             Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n        chairperson = msg.sender;\n        voters[chairperson].weight = 1;\n\n        // For each of the provided proposal names,\n        // create a new proposal object and add it\n        // to the end of the array.\n        for (uint i = 0; i < proposalNames.length; i++) {\n            // `Proposal({...})` creates a temporary\n            // Proposal object and `proposals.push(...)`\n            // appends it to the end of `proposals`.\n            proposals.push(Proposal({\n                name: proposalNames[i],\n                voteCount: 0\n            }));\n        }\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "chairperson = msg.sender"
        Assignment using operator =
           Type: address
           Source: "chairperson = msg.sender"
          Identifier chairperson
             Type: address
             Source: "chairperson"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "voters[chairperson].weight = 1"
        Assignment using operator =
           Type: uint256
           Source: "voters[chairperson].weight = 1"
          MemberAccess to member weight
             Type: uint256
             Source: "voters[chairperson].weight"
            IndexAccess
               Type: struct Ballot.Voter storage ref
               Source: "voters[chairperson]"
              Identifier voters
                 Type: mapping(address => struct Ballot.Voter storage ref)
                 Source: "voters"
              Identifier chairperson
                 Type: address
                 Source: "chairperson"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      ForStatement
         Source: "for (uint i = 0; i < proposalNames.length; i++) {\n            // `Proposal({...})` creates a temporary\n            // Proposal object and `proposals.push(...)`\n            // appends it to the end of `proposals`.\n            proposals.push(Proposal({\n                name: proposalNames[i],\n                voteCount: 0\n            }));\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < proposalNames.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "proposalNames.length"
            Identifier proposalNames
               Type: bytes32[] memory
               Source: "proposalNames"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\n            // `Proposal({...})` creates a temporary\n            // Proposal object and `proposals.push(...)`\n            // appends it to the end of `proposals`.\n            proposals.push(Proposal({\n                name: proposalNames[i],\n                voteCount: 0\n            }));\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "proposals.push(Proposal({\n                name: proposalNames[i],\n                voteCount: 0\n            }))"
            FunctionCall
               Type: uint256
               Source: "proposals.push(Proposal({\n                name: proposalNames[i],\n                voteCount: 0\n            }))"
              MemberAccess to member push
                 Type: function (struct Ballot.Proposal storage ref) returns (uint256)
                 Source: "proposals.push"
                Identifier proposals
                   Type: struct Ballot.Proposal storage ref[] storage ref
                   Source: "proposals"
              FunctionCall
                 Type: struct Ballot.Proposal memory
                 Source: "Proposal({\n                name: proposalNames[i],\n                voteCount: 0\n            })"
                Identifier Proposal
                   Type: type(struct Ballot.Proposal storage pointer)
                   Source: "Proposal"
                IndexAccess
                   Type: bytes32
                   Source: "proposalNames[i]"
                  Identifier proposalNames
                     Type: bytes32[] memory
                     Source: "proposalNames"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
  FunctionDefinition "giveRightToVote" - public
     Source: "function giveRightToVote(address voter) public {\n        // If the first argument of `require` evaluates\n        // to `false`, execution terminates and all\n        // changes to the state and to Ether balances\n        // are reverted.\n        // This used to consume all gas in old EVM versions, but\n        // not anymore.\n        // It is often a good idea to use `require` to check if\n        // functions are called correctly.\n        // As a second argument, you can also provide an\n        // explanation about what went wrong.\n        require(\n            msg.sender == chairperson,\n            \"Only chairperson can give right to vote.\"\n        );\n        require(\n            !voters[voter].voted,\n            \"The voter already voted.\"\n        );\n        require(voters[voter].weight == 0);\n        voters[voter].weight = 1;\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address voter)"
      VariableDeclaration "voter"
         Type: address
         Source: "address voter"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n        // If the first argument of `require` evaluates\n        // to `false`, execution terminates and all\n        // changes to the state and to Ether balances\n        // are reverted.\n        // This used to consume all gas in old EVM versions, but\n        // not anymore.\n        // It is often a good idea to use `require` to check if\n        // functions are called correctly.\n        // As a second argument, you can also provide an\n        // explanation about what went wrong.\n        require(\n            msg.sender == chairperson,\n            \"Only chairperson can give right to vote.\"\n        );\n        require(\n            !voters[voter].voted,\n            \"The voter already voted.\"\n        );\n        require(voters[voter].weight == 0);\n        voters[voter].weight = 1;\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(\n            msg.sender == chairperson,\n            \"Only chairperson can give right to vote.\"\n        )"
        FunctionCall
           Type: tuple()
           Source: "require(\n            msg.sender == chairperson,\n            \"Only chairperson can give right to vote.\"\n        )"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == chairperson"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier chairperson
               Type: address
               Source: "chairperson"
          Literal, token: [no token] value: Only chairperson can give right to vote.
             Type: literal_string "Only chairperson can give right to vote."
             Source: "\"Only chairperson can give right to vote.\""
      ExpressionStatement
         Gas costs: [???]
         Source: "require(\n            !voters[voter].voted,\n            \"The voter already voted.\"\n        )"
        FunctionCall
           Type: tuple()
           Source: "require(\n            !voters[voter].voted,\n            \"The voter already voted.\"\n        )"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!voters[voter].voted"
            MemberAccess to member voted
               Type: bool
               Source: "voters[voter].voted"
              IndexAccess
                 Type: struct Ballot.Voter storage ref
                 Source: "voters[voter]"
                Identifier voters
                   Type: mapping(address => struct Ballot.Voter storage ref)
                   Source: "voters"
                Identifier voter
                   Type: address
                   Source: "voter"
          Literal, token: [no token] value: The voter already voted.
             Type: literal_string "The voter already voted."
             Source: "\"The voter already voted.\""
      ExpressionStatement
         Gas costs: 337
         Source: "require(voters[voter].weight == 0)"
        FunctionCall
           Type: tuple()
           Source: "require(voters[voter].weight == 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "voters[voter].weight == 0"
            MemberAccess to member weight
               Type: uint256
               Source: "voters[voter].weight"
              IndexAccess
                 Type: struct Ballot.Voter storage ref
                 Source: "voters[voter]"
                Identifier voters
                   Type: mapping(address => struct Ballot.Voter storage ref)
                   Source: "voters"
                Identifier voter
                   Type: address
                   Source: "voter"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20116
         Source: "voters[voter].weight = 1"
        Assignment using operator =
           Type: uint256
           Source: "voters[voter].weight = 1"
          MemberAccess to member weight
             Type: uint256
             Source: "voters[voter].weight"
            IndexAccess
               Type: struct Ballot.Voter storage ref
               Source: "voters[voter]"
              Identifier voters
                 Type: mapping(address => struct Ballot.Voter storage ref)
                 Source: "voters"
              Identifier voter
                 Type: address
                 Source: "voter"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
  FunctionDefinition "delegate" - public
     Source: "function delegate(address to) public {\n        // assigns reference\n        Voter storage sender = voters[msg.sender];\n        require(!sender.voted, \"You already voted.\");\n\n        require(to != msg.sender, \"Self-delegation is disallowed.\");\n\n        // Forward the delegation as long as\n        // `to` also delegated.\n        // In general, such loops are very dangerous,\n        // because if they run too long, they might\n        // need more gas than is available in a block.\n        // In this case, the delegation will not be executed,\n        // but in other situations, such loops might\n        // cause a contract to get \"stuck\" completely.\n        while (voters[to].delegate != address(0)) {\n            to = voters[to].delegate;\n\n            // We found a loop in the delegation, not allowed.\n            require(to != msg.sender, \"Found loop in delegation.\");\n        }\n\n        // Since `sender` is a reference, this\n        // modifies `voters[msg.sender].voted`\n        sender.voted = true;\n        sender.delegate = to;\n        Voter storage delegate_ = voters[to];\n        if (delegate_.voted) {\n            // If the delegate already voted,\n            // directly add to the number of votes\n            proposals[delegate_.vote].voteCount += sender.weight;\n        } else {\n            // If the delegate did not vote yet,\n            // add to her weight.\n            delegate_.weight += sender.weight;\n        }\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address to)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n        // assigns reference\n        Voter storage sender = voters[msg.sender];\n        require(!sender.voted, \"You already voted.\");\n\n        require(to != msg.sender, \"Self-delegation is disallowed.\");\n\n        // Forward the delegation as long as\n        // `to` also delegated.\n        // In general, such loops are very dangerous,\n        // because if they run too long, they might\n        // need more gas than is available in a block.\n        // In this case, the delegation will not be executed,\n        // but in other situations, such loops might\n        // cause a contract to get \"stuck\" completely.\n        while (voters[to].delegate != address(0)) {\n            to = voters[to].delegate;\n\n            // We found a loop in the delegation, not allowed.\n            require(to != msg.sender, \"Found loop in delegation.\");\n        }\n\n        // Since `sender` is a reference, this\n        // modifies `voters[msg.sender].voted`\n        sender.voted = true;\n        sender.delegate = to;\n        Voter storage delegate_ = voters[to];\n        if (delegate_.voted) {\n            // If the delegate already voted,\n            // directly add to the number of votes\n            proposals[delegate_.vote].voteCount += sender.weight;\n        } else {\n            // If the delegate did not vote yet,\n            // add to her weight.\n            delegate_.weight += sender.weight;\n        }\n    }"
      VariableDeclarationStatement
         Gas costs: 106
         Source: "Voter storage sender = voters[msg.sender]"
        VariableDeclaration "sender"
           Type: struct Ballot.Voter storage pointer
           Source: "Voter storage sender"
          UserDefinedTypeName "Voter"
             Source: "Voter"
        IndexAccess
           Type: struct Ballot.Voter storage ref
           Source: "voters[msg.sender]"
          Identifier voters
             Type: mapping(address => struct Ballot.Voter storage ref)
             Source: "voters"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(!sender.voted, \"You already voted.\")"
        FunctionCall
           Type: tuple()
           Source: "require(!sender.voted, \"You already voted.\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!sender.voted"
            MemberAccess to member voted
               Type: bool
               Source: "sender.voted"
              Identifier sender
                 Type: struct Ballot.Voter storage pointer
                 Source: "sender"
          Literal, token: [no token] value: You already voted.
             Type: literal_string "You already voted."
             Source: "\"You already voted.\""
      ExpressionStatement
         Gas costs: [???]
         Source: "require(to != msg.sender, \"Self-delegation is disallowed.\")"
        FunctionCall
           Type: tuple()
           Source: "require(to != msg.sender, \"Self-delegation is disallowed.\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "to != msg.sender"
            Identifier to
               Type: address
               Source: "to"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: [no token] value: Self-delegation is disallowed.
             Type: literal_string "Self-delegation is disallowed."
             Source: "\"Self-delegation is disallowed.\""
      WhileStatement
         Source: "while (voters[to].delegate != address(0)) {\n            to = voters[to].delegate;\n\n            // We found a loop in the delegation, not allowed.\n            require(to != msg.sender, \"Found loop in delegation.\");\n        }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 412
           Source: "voters[to].delegate != address(0)"
          MemberAccess to member delegate
             Type: address
             Source: "voters[to].delegate"
            IndexAccess
               Type: struct Ballot.Voter storage ref
               Source: "voters[to]"
              Identifier voters
                 Type: mapping(address => struct Ballot.Voter storage ref)
                 Source: "voters"
              Identifier to
                 Type: address
                 Source: "to"
          FunctionCall
             Type: address
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\n            to = voters[to].delegate;\n\n            // We found a loop in the delegation, not allowed.\n            require(to != msg.sender, \"Found loop in delegation.\");\n        }"
          ExpressionStatement
             Gas costs: 396
             Source: "to = voters[to].delegate"
            Assignment using operator =
               Type: address
               Source: "to = voters[to].delegate"
              Identifier to
                 Type: address
                 Source: "to"
              MemberAccess to member delegate
                 Type: address
                 Source: "voters[to].delegate"
                IndexAccess
                   Type: struct Ballot.Voter storage ref
                   Source: "voters[to]"
                  Identifier voters
                     Type: mapping(address => struct Ballot.Voter storage ref)
                     Source: "voters"
                  Identifier to
                     Type: address
                     Source: "to"
          ExpressionStatement
             Gas costs: [???]
             Source: "require(to != msg.sender, \"Found loop in delegation.\")"
            FunctionCall
               Type: tuple()
               Source: "require(to != msg.sender, \"Found loop in delegation.\")"
              Identifier require
                 Type: function (bool,string memory) pure
                 Source: "require"
              BinaryOperation using operator !=
                 Type: bool
                 Source: "to != msg.sender"
                Identifier to
                   Type: address
                   Source: "to"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Literal, token: [no token] value: Found loop in delegation.
                 Type: literal_string "Found loop in delegation."
                 Source: "\"Found loop in delegation.\""
      ExpressionStatement
         Gas costs: 20273
         Source: "sender.voted = true"
        Assignment using operator =
           Type: bool
           Source: "sender.voted = true"
          MemberAccess to member voted
             Type: bool
             Source: "sender.voted"
            Identifier sender
               Type: struct Ballot.Voter storage pointer
               Source: "sender"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 20323
         Source: "sender.delegate = to"
        Assignment using operator =
           Type: address
           Source: "sender.delegate = to"
          MemberAccess to member delegate
             Type: address
             Source: "sender.delegate"
            Identifier sender
               Type: struct Ballot.Voter storage pointer
               Source: "sender"
          Identifier to
             Type: address
             Source: "to"
      VariableDeclarationStatement
         Gas costs: 107
         Source: "Voter storage delegate_ = voters[to]"
        VariableDeclaration "delegate_"
           Type: struct Ballot.Voter storage pointer
           Source: "Voter storage delegate_"
          UserDefinedTypeName "Voter"
             Source: "Voter"
        IndexAccess
           Type: struct Ballot.Voter storage ref
           Source: "voters[to]"
          Identifier voters
             Type: mapping(address => struct Ballot.Voter storage ref)
             Source: "voters"
          Identifier to
             Type: address
             Source: "to"
      IfStatement
         Source: "if (delegate_.voted) {\n            // If the delegate already voted,\n            // directly add to the number of votes\n            proposals[delegate_.vote].voteCount += sender.weight;\n        } else {\n            // If the delegate did not vote yet,\n            // add to her weight.\n            delegate_.weight += sender.weight;\n        }"
        MemberAccess to member voted
           Type: bool
           Gas costs: 245
           Source: "delegate_.voted"
          Identifier delegate_
             Type: struct Ballot.Voter storage pointer
             Source: "delegate_"
        Block
           Source: "{\n            // If the delegate already voted,\n            // directly add to the number of votes\n            proposals[delegate_.vote].voteCount += sender.weight;\n        }"
          ExpressionStatement
             Gas costs: 20951
             Source: "proposals[delegate_.vote].voteCount += sender.weight"
            Assignment using operator +=
               Type: uint256
               Source: "proposals[delegate_.vote].voteCount += sender.weight"
              MemberAccess to member voteCount
                 Type: uint256
                 Source: "proposals[delegate_.vote].voteCount"
                IndexAccess
                   Type: struct Ballot.Proposal storage ref
                   Source: "proposals[delegate_.vote]"
                  Identifier proposals
                     Type: struct Ballot.Proposal storage ref[] storage ref
                     Source: "proposals"
                  MemberAccess to member vote
                     Type: uint256
                     Source: "delegate_.vote"
                    Identifier delegate_
                       Type: struct Ballot.Voter storage pointer
                       Source: "delegate_"
              MemberAccess to member weight
                 Type: uint256
                 Source: "sender.weight"
                Identifier sender
                   Type: struct Ballot.Voter storage pointer
                   Source: "sender"
        Block
           Source: "{\n            // If the delegate did not vote yet,\n            // add to her weight.\n            delegate_.weight += sender.weight;\n        }"
          ExpressionStatement
             Gas costs: 20445
             Source: "delegate_.weight += sender.weight"
            Assignment using operator +=
               Type: uint256
               Source: "delegate_.weight += sender.weight"
              MemberAccess to member weight
                 Type: uint256
                 Source: "delegate_.weight"
                Identifier delegate_
                   Type: struct Ballot.Voter storage pointer
                   Source: "delegate_"
              MemberAccess to member weight
                 Type: uint256
                 Source: "sender.weight"
                Identifier sender
                   Type: struct Ballot.Voter storage pointer
                   Source: "sender"
  FunctionDefinition "vote" - public
     Source: "function vote(uint proposal) public {\n        Voter storage sender = voters[msg.sender];\n        require(!sender.voted, \"Already voted.\");\n        sender.voted = true;\n        sender.vote = proposal;\n\n        // If `proposal` is out of the range of the array,\n        // this will throw automatically and revert all\n        // changes.\n        proposals[proposal].voteCount += sender.weight;\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint proposal)"
      VariableDeclaration "proposal"
         Type: uint256
         Source: "uint proposal"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n        Voter storage sender = voters[msg.sender];\n        require(!sender.voted, \"Already voted.\");\n        sender.voted = true;\n        sender.vote = proposal;\n\n        // If `proposal` is out of the range of the array,\n        // this will throw automatically and revert all\n        // changes.\n        proposals[proposal].voteCount += sender.weight;\n    }"
      VariableDeclarationStatement
         Gas costs: 106
         Source: "Voter storage sender = voters[msg.sender]"
        VariableDeclaration "sender"
           Type: struct Ballot.Voter storage pointer
           Source: "Voter storage sender"
          UserDefinedTypeName "Voter"
             Source: "Voter"
        IndexAccess
           Type: struct Ballot.Voter storage ref
           Source: "voters[msg.sender]"
          Identifier voters
             Type: mapping(address => struct Ballot.Voter storage ref)
             Source: "voters"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(!sender.voted, \"Already voted.\")"
        FunctionCall
           Type: tuple()
           Source: "require(!sender.voted, \"Already voted.\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!sender.voted"
            MemberAccess to member voted
               Type: bool
               Source: "sender.voted"
              Identifier sender
                 Type: struct Ballot.Voter storage pointer
                 Source: "sender"
          Literal, token: [no token] value: Already voted.
             Type: literal_string "Already voted."
             Source: "\"Already voted.\""
      ExpressionStatement
         Gas costs: 20273
         Source: "sender.voted = true"
        Assignment using operator =
           Type: bool
           Source: "sender.voted = true"
          MemberAccess to member voted
             Type: bool
             Source: "sender.voted"
            Identifier sender
               Type: struct Ballot.Voter storage pointer
               Source: "sender"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 20020
         Source: "sender.vote = proposal"
        Assignment using operator =
           Type: uint256
           Source: "sender.vote = proposal"
          MemberAccess to member vote
             Type: uint256
             Source: "sender.vote"
            Identifier sender
               Type: struct Ballot.Voter storage pointer
               Source: "sender"
          Identifier proposal
             Type: uint256
             Source: "proposal"
      ExpressionStatement
         Gas costs: 20745
         Source: "proposals[proposal].voteCount += sender.weight"
        Assignment using operator +=
           Type: uint256
           Source: "proposals[proposal].voteCount += sender.weight"
          MemberAccess to member voteCount
             Type: uint256
             Source: "proposals[proposal].voteCount"
            IndexAccess
               Type: struct Ballot.Proposal storage ref
               Source: "proposals[proposal]"
              Identifier proposals
                 Type: struct Ballot.Proposal storage ref[] storage ref
                 Source: "proposals"
              Identifier proposal
                 Type: uint256
                 Source: "proposal"
          MemberAccess to member weight
             Type: uint256
             Source: "sender.weight"
            Identifier sender
               Type: struct Ballot.Voter storage pointer
               Source: "sender"
  FunctionDefinition "winningProposal" - public - const
     Source: "function winningProposal() public view\n            returns (uint winningProposal_)\n    {\n        uint winningVoteCount = 0;\n        for (uint p = 0; p < proposals.length; p++) {\n            if (proposals[p].voteCount > winningVoteCount) {\n                winningVoteCount = proposals[p].voteCount;\n                winningProposal_ = p;\n            }\n        }\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint winningProposal_)"
      VariableDeclaration "winningProposal_"
         Type: uint256
         Source: "uint winningProposal_"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\n        uint winningVoteCount = 0;\n        for (uint p = 0; p < proposals.length; p++) {\n            if (proposals[p].voteCount > winningVoteCount) {\n                winningVoteCount = proposals[p].voteCount;\n                winningProposal_ = p;\n            }\n        }\n    }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint winningVoteCount = 0"
        VariableDeclaration "winningVoteCount"
           Type: uint256
           Source: "uint winningVoteCount"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      ForStatement
         Source: "for (uint p = 0; p < proposals.length; p++) {\n            if (proposals[p].voteCount > winningVoteCount) {\n                winningVoteCount = proposals[p].voteCount;\n                winningProposal_ = p;\n            }\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint p = 0"
          VariableDeclaration "p"
             Type: uint256
             Source: "uint p"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 217
           Source: "p < proposals.length"
          Identifier p
             Type: uint256
             Source: "p"
          MemberAccess to member length
             Type: uint256
             Source: "proposals.length"
            Identifier proposals
               Type: struct Ballot.Proposal storage ref[] storage ref
               Source: "proposals"
        ExpressionStatement
           Gas costs: 19
           Source: "p++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "p++"
            Identifier p
               Type: uint256
               Source: "p"
        Block
           Source: "{\n            if (proposals[p].voteCount > winningVoteCount) {\n                winningVoteCount = proposals[p].voteCount;\n                winningProposal_ = p;\n            }\n        }"
          IfStatement
             Source: "if (proposals[p].voteCount > winningVoteCount) {\n                winningVoteCount = proposals[p].voteCount;\n                winningProposal_ = p;\n            }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 515
               Source: "proposals[p].voteCount > winningVoteCount"
              MemberAccess to member voteCount
                 Type: uint256
                 Source: "proposals[p].voteCount"
                IndexAccess
                   Type: struct Ballot.Proposal storage ref
                   Source: "proposals[p]"
                  Identifier proposals
                     Type: struct Ballot.Proposal storage ref[] storage ref
                     Source: "proposals"
                  Identifier p
                     Type: uint256
                     Source: "p"
              Identifier winningVoteCount
                 Type: uint256
                 Source: "winningVoteCount"
            Block
               Source: "{\n                winningVoteCount = proposals[p].voteCount;\n                winningProposal_ = p;\n            }"
              ExpressionStatement
                 Gas costs: 514
                 Source: "winningVoteCount = proposals[p].voteCount"
                Assignment using operator =
                   Type: uint256
                   Source: "winningVoteCount = proposals[p].voteCount"
                  Identifier winningVoteCount
                     Type: uint256
                     Source: "winningVoteCount"
                  MemberAccess to member voteCount
                     Type: uint256
                     Source: "proposals[p].voteCount"
                    IndexAccess
                       Type: struct Ballot.Proposal storage ref
                       Source: "proposals[p]"
                      Identifier proposals
                         Type: struct Ballot.Proposal storage ref[] storage ref
                         Source: "proposals"
                      Identifier p
                         Type: uint256
                         Source: "p"
              ExpressionStatement
                 Gas costs: 8
                 Source: "winningProposal_ = p"
                Assignment using operator =
                   Type: uint256
                   Source: "winningProposal_ = p"
                  Identifier winningProposal_
                     Type: uint256
                     Source: "winningProposal_"
                  Identifier p
                     Type: uint256
                     Source: "p"
  FunctionDefinition "winnerName" - public - const
     Source: "function winnerName() public view\n            returns (bytes32 winnerName_)\n    {\n        winnerName_ = proposals[winningProposal()].name;\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bytes32 winnerName_)"
      VariableDeclaration "winnerName_"
         Type: bytes32
         Source: "bytes32 winnerName_"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\n        winnerName_ = proposals[winningProposal()].name;\n    }"
      ExpressionStatement
         Gas costs: 526
         Source: "winnerName_ = proposals[winningProposal()].name"
        Assignment using operator =
           Type: bytes32
           Source: "winnerName_ = proposals[winningProposal()].name"
          Identifier winnerName_
             Type: bytes32
             Source: "winnerName_"
          MemberAccess to member name
             Type: bytes32
             Source: "proposals[winningProposal()].name"
            IndexAccess
               Type: struct Ballot.Proposal storage ref
               Source: "proposals[winningProposal()]"
              Identifier proposals
                 Type: struct Ballot.Proposal storage ref[] storage ref
                 Source: "proposals"
              FunctionCall
                 Type: uint256
                 Source: "winningProposal()"
                Identifier winningProposal
                   Type: function () view returns (uint256)
                   Source: "winningProposal"
